/*
 * Copyright 2018 Murat Artim (muratartim@gmail.com).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package equinox.task;

import java.io.BufferedWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.logging.Level;

import equinox.Equinox;
import equinox.data.ExcaliburElement2DStressSortingCriteria;
import equinox.data.ExcaliburStressSortingCriteria;
import equinox.data.input.ExcaliburInput;
import equinox.plugin.FileType;
import equinox.process.ExcaliburLoadLoadcaseCorrelations;
import equinox.task.InternalEquinoxTask.ShortRunningTask;

/**
 * Class for Excalibur 2D element stress sorting task.
 *
 * @author Murat Artim
 * @date 3 Dec 2017
 * @time 00:25:06
 */
public class ExcaliburSort2DElementStresses extends InternalEquinoxTask<Void> implements ShortRunningTask {

	/** STF file ID. */
	private final long stfFileID;

	/** STF file name. */
	private final String stfFileName;

	/** Analysis table names and aircraft section and mission. */
	private final String[] analysisTables, sectionMission;

	/** Analysis input. */
	private final ExcaliburInput input;

	/** Output directories. */
	private final Path outputLogDir, outputStfDir;

	/** Formatter for real numbers. */
	private final DecimalFormat numberFormat_ = new DecimalFormat("0.00");

	/**
	 * Creates Excalibur 2D element stress sorting task.
	 *
	 * @param stfFileID
	 *            STF file ID.
	 * @param stfFileName
	 *            STF file name.
	 * @param analysisTables
	 *            Analysis table names.
	 * @param sectionMission
	 *            Aircraft section and mission.
	 * @param input
	 *            Analysis input.
	 * @param outputStfDir
	 *            Output directory where the STF files will be written to.
	 * @param outputLogDir
	 *            Output directory where the log files will be written to. Can be null for no logging.
	 */
	public ExcaliburSort2DElementStresses(long stfFileID, String stfFileName, String[] analysisTables, String[] sectionMission, ExcaliburInput input, Path outputStfDir, Path outputLogDir) {
		this.stfFileID = stfFileID;
		this.stfFileName = stfFileName;
		this.analysisTables = analysisTables;
		this.sectionMission = sectionMission;
		this.input = input;
		this.outputLogDir = outputLogDir;
		this.outputStfDir = outputStfDir;
	}

	@Override
	public boolean canBeCancelled() {
		return true;
	}

	@Override
	public String getTaskTitle() {
		return "Stress sorting '" + stfFileName + "'";
	}

	@Override
	protected Void call() throws Exception {

		// update info
		updateMessage("Sorting process started...");

		// create logger
		if (!input.getLogLevel().equals(Level.OFF)) {
			Path outputLog = outputLogDir.resolve(FileType.getNameWithoutExtension(stfFileName) + ".log");
			createLogger(analysisTables[Excalibur.STF_FILES] + "_" + stfFileID, outputLog, input.getLogLevel());
		}

		// create path to output STF file
		Path outputStf = outputStfDir.resolve(stfFileName);

		// create database connection
		try (Connection connection = Equinox.DBC_POOL.getConnection()) {

			// create statement for selecting attributes table rows
			try (Statement selectAttributesTable = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY)) {

				// prepare statement for selecting load case keys
				String sql = "select lc_name, lc_num from " + analysisTables[Excalibur.LCK] + " where section = '";
				sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + "' and mission = '";
				sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + "' and (segment = ? or segment = ?) and load_type like ?";
				try (PreparedStatement selectLCKeys = connection.prepareStatement(sql)) {

					// create statement for selecting stresses
					try (Statement selectStresses = connection.createStatement()) {
						selectStresses.setMaxRows(1);

						// create output file writer
						try (BufferedWriter writer = Files.newBufferedWriter(outputStf, Charset.defaultCharset())) {

							// write file header
							String line = "# STF file generated by Excalibur " + Excalibur.VERSION + ", Stress Sorting Plugin of Equinox." + Equinox.VERSION.toString() + ", for ";
							line += "A/C section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", fatigue mission: ";
							line += sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", stress file name: " + stfFileName;
							line += ", stress sorting criteria: " + input.getStressSortingCriteria().toString();
							writer.write(line);
							writer.newLine();
							line = String.format("%-10s", "LOADCASE");
							line += String.format("%-10s", "SX");
							line += String.format("%-10s", "SY");
							line += String.format("%-10s", "SXY");
							writer.write(line);
							writer.newLine();

							// add delta-p load case
							long deltapID = addDP(selectStresses, writer);

							// select load cases from attributes table
							sql = "select * from " + analysisTables[Excalibur.XLS] + " where section = '";
							sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + "' and mission = '";
							sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + "' and ";
							sql += "id <> " + deltapID;
							try (ResultSet attributesTable = selectAttributesTable.executeQuery(sql)) {

								// create list to store load case names
								ArrayList<String> lcNames = new ArrayList<>();

								// get number of rows in the attributes table
								int numRows = 0;
								if (attributesTable.last()) {
									numRows = attributesTable.getRow();
									attributesTable.beforeFirst();
								}

								// no rows found
								if (numRows == 0) {
									String msg = "No fatigue event found in attributes table for - ";
									msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
									msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ". ";
									msg += "No STF is generated.";
									throw new Exception(msg);
								}

								// loop over attributes table rows
								int currentRow = 0;
								while (attributesTable.next()) {

									// task cancelled
									if (isCancelled())
										return null;

									// get conversion table columns
									String segment = attributesTable.getString("segment");
									String loadcaseNum = attributesTable.getString("issy_code");
									String eventName = attributesTable.getString("event_name");
									String loadType = attributesTable.getString("load_type");
									String eventComment = attributesTable.getString("event_comment");
									String loadCriteria = attributesTable.getString("load_criteria");
									double loadFactor = attributesTable.getDouble("load_factor");

									// update info
									updateMessage("Processing '" + eventComment + "'...");
									updateProgress(currentRow, numRows);
									currentRow++;

									// set segment
									if (segment.contains("|")) {
										String[] split = segment.split("\\|");
										selectLCKeys.setString(1, split[0]);
										selectLCKeys.setString(2, split[1]);
									}
									else {
										selectLCKeys.setString(1, segment);
										selectLCKeys.setString(2, segment);
									}

									// set parameters
									selectLCKeys.setString(3, "%" + loadType + "%");

									// select load case keys
									try (ResultSet lcKeys = selectLCKeys.executeQuery()) {

										// create SQL query for selecting stresses
										sql = createStressSelectionQuery(lcKeys, segment, loadcaseNum, eventName, loadType, eventComment, loadCriteria, lcNames);

										// no load case found in load case keys
										if (sql == null) {
											line = String.format("%-10s", loadcaseNum);
											line += String.format("%-10s", numberFormat_.format(0.0));
											line += String.format("%-10s", numberFormat_.format(0.0));
											line += String.format("%-10s", numberFormat_.format(0.0));
											writer.write(line);
											writer.newLine();
											continue;
										}

										// select stresses
										try (ResultSet stresses = selectStresses.executeQuery(sql)) {

											// write stresses
											if (!writeStresses(stresses, segment, loadcaseNum, eventName, loadType, eventComment, lcNames, loadFactor, writer)) {
												line = String.format("%-10s", loadcaseNum);
												line += String.format("%-10s", numberFormat_.format(0.0));
												line += String.format("%-10s", numberFormat_.format(0.0));
												line += String.format("%-10s", numberFormat_.format(0.0));
												writer.write(line);
												writer.newLine();
												continue;
											}
										}
									}
								}
							}
						}

						// reset statement
						selectStresses.setMaxRows(0);
					}
				}
			}
		}
		return null;
	}

	/**
	 * Writes out the extracted (selected) stresses to output file.
	 *
	 * @param stresses
	 *            Result set containing the selected stresses.
	 * @param segment
	 *            Segment name.
	 * @param loadcaseNum
	 *            Loadcase number.
	 * @param eventName
	 *            Event name.
	 * @param loadType
	 *            Load type.
	 * @param eventComment
	 *            Event comment.
	 * @param lcNames
	 *            List containing the load case names.
	 * @param loadFactor
	 *            Load factor.
	 * @param writer
	 *            File writer.
	 * @return True if the stresses are found.
	 * @throws Exception
	 *             If exception occurs during process.
	 */
	private boolean writeStresses(ResultSet stresses, String segment, String loadcaseNum, String eventName, String loadType, String eventComment, ArrayList<String> lcNames, double loadFactor, BufferedWriter writer) throws Exception {

		// loop over stresses
		int found = 0;
		String line;
		while (stresses.next()) {

			// write stresses
			line = String.format("%-10s", loadcaseNum);
			double sx = stresses.getDouble("sx");
			double sy = stresses.getDouble("sy");
			double sxy = stresses.getDouble("sxy");
			line += String.format("%-10s", numberFormat_.format(sx * loadFactor));
			line += String.format("%-10s", numberFormat_.format(sy * loadFactor));
			line += String.format("%-10s", numberFormat_.format(sxy * loadFactor));
			writer.write(line);
			writer.newLine();
			found++;

			// log fine
			if ((logger_ != null) && logger_.getLevel().equals(Level.FINE)) {
				String msg = "Stress found for fatigue event - ";
				msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
				msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", ";
				msg += "segment: " + segment + ", ";
				msg += "loadcase number (from attributes table): " + loadcaseNum + ", ";
				msg += "event name: " + eventName + ", ";
				msg += "load type: " + loadType + ", ";
				msg += "event comment: " + eventComment + ", ";
				msg += "load case number (from stress file): " + stresses.getInt("lc_num") + ", ";
				msg += "stress SX: " + sx + ", ";
				msg += "stress SY: " + sy + ", ";
				msg += "stress SXY: " + sxy + ", ";
				msg += "load factor: " + loadFactor + ".";
				logger_.fine(msg);
			}
		}

		// no stress found
		if (found == 0) {
			if (logger_ != null) {
				String msg = "No stress found for fatigue event - ";
				msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
				msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", ";
				msg += "segment: " + segment + ", ";
				msg += "loadcase number: " + loadcaseNum + ", ";
				msg += "event name: " + eventName + ", ";
				msg += "load type: " + loadType + ", ";
				msg += "event comment: " + eventComment + ", ";
				msg += "load cases: ";
				for (String name : lcNames) {
					msg += name + ", ";
				}
				msg += "Stresses will be set to 0.0 for loadcase '" + loadcaseNum + "' in the output STF file.";
				logger_.warning(msg);
			}
			return false;
		}
		return true;
	}

	/**
	 * Creates and returns the stress selection SQL query for the given stress selection criteria and load criteria from the conversion table.
	 *
	 * @param lcKeys
	 *            Load case keys.
	 * @param segment
	 *            Segment name.
	 * @param loadcaseNum
	 *            Loadcase number.
	 * @param eventName
	 *            Event name.
	 * @param loadType
	 *            Load type.
	 * @param eventComment
	 *            Event comment.
	 * @param loadCriteria
	 *            Load criteria.
	 * @param lcNames
	 *            List storing the load case names.
	 * @return Stress selection SQL query or null if no load case is found in the load case keys.
	 * @throws Exception
	 *             If exception occurs during process.
	 */
	private String createStressSelectionQuery(ResultSet lcKeys, String segment, String loadcaseNum, String eventName, String loadType, String eventComment, String loadCriteria, ArrayList<String> lcNames) throws Exception {

		// initialize query
		String sql = "select lc_num, sx, sy, sxy from " + analysisTables[Excalibur.STF_STRESSES] + " where ";

		// add station criteria
		sql += "file_id = " + stfFileID + " and (";

		// add load case name criterion
		lcNames.clear();
		while (lcKeys.next()) {
			lcNames.add(lcKeys.getString("lc_name"));
			sql += "(lc_num = " + lcKeys.getInt("lc_num") + ") or ";
		}
		sql = sql.substring(0, sql.length() - " or ".length()) + ") ";

		// no load case found in load case keys
		if (lcNames.isEmpty()) {
			if (logger_ != null) {
				String msg = "No load case found in load case keys for fatigue event - ";
				msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
				msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", ";
				msg += "segment: " + segment + ", ";
				msg += "load case number: " + loadcaseNum + ", ";
				msg += "event name: " + eventName + ", ";
				msg += "load type: " + loadType + ", ";
				msg += "event comment: " + eventComment + ", ";
				msg += "Stresses will be set to 0.0 for load case '" + loadcaseNum + "' in the output STF file.";
				logger_.warning(msg);
			}
			return null;
		}

		// get stress sorting criteria
		ExcaliburStressSortingCriteria criteria = input.getStressSortingCriteria();

		// load criteria is 'MAX_ABS'
		if (loadCriteria.equals("MAX_ABS")) {
			sql += "order by ";
			if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_PRINCIPAL)) {
				sql += "abs_max_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SX)) {
				sql += "abs(sx)";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SY)) {
				sql += "abs(sy)";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SXY)) {
				sql += "abs(sxy)";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_PRINCIPAL)) {
				sql += "max_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SX)) {
				sql += "sx";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SY)) {
				sql += "sy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SXY)) {
				sql += "sxy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ROTATED_STRESS)) {
				sql += "(0.5 * (sx + sy) + 0.5 * (sx - sy) * cos(2 * " + input.getRotationAngle() + ") + sxy * sin(2 * " + input.getRotationAngle() + "))";
			}
			sql += " desc";
		}

		// load criteria is 'MAX'
		else if (loadCriteria.equals("MAX")) {
			sql += "order by ";
			if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_PRINCIPAL)) {
				sql += "max_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SX)) {
				sql += "sx";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SY)) {
				sql += "sy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SXY)) {
				sql += "sxy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_PRINCIPAL)) {
				sql += "max_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SX)) {
				sql += "sx";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SY)) {
				sql += "sy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SXY)) {
				sql += "sxy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ROTATED_STRESS)) {
				sql += "(0.5 * (sx + sy) + 0.5 * (sx - sy) * cos(2 * " + input.getRotationAngle() + ") + sxy * sin(2 * " + input.getRotationAngle() + "))";
			}
			sql += " desc";
		}

		// load criteria is 'MIN'
		else if (loadCriteria.equals("MIN")) {
			sql += "order by ";
			if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_PRINCIPAL)) {
				sql += "min_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SX)) {
				sql += "sx";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SY)) {
				sql += "sy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ABS_SXY)) {
				sql += "sxy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_PRINCIPAL)) {
				sql += "min_sigma";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SX)) {
				sql += "sx";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SY)) {
				sql += "sy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_SXY)) {
				sql += "sxy";
			}
			else if (criteria.equals(ExcaliburElement2DStressSortingCriteria.MAX_ROTATED_STRESS)) {
				sql += "(0.5 * (sx + sy) + 0.5 * (sx - sy) * cos(2 * " + input.getRotationAngle() + ") + sxy * sin(2 * " + input.getRotationAngle() + "))";
			}
			sql += " asc";
		}

		// return query
		return sql;
	}

	/**
	 * Adds delta-p stresses to output file.
	 *
	 * @param selectStresses
	 *            Database statement for selecting stresses.
	 * @param writer
	 *            File writer.
	 * @return Delta-p issy code ID in attributes table.
	 * @throws Exception
	 *             If exception occurs during process.
	 */
	private long addDP(Statement selectStresses, BufferedWriter writer) throws Exception {

		// initialize delta-p issy code ID in attributes table
		long deltapID = -1L;

		// get delta-p loadcase number
		Integer dp = input.getDpLoadcaseNumber();

		// no delta-p required
		if (dp == null) {
			if (logger_ != null) {
				logger_.info("The optional input 'Dealta-p load case number' is not supplied. Delta-p load case will not be added to output STF file.");
			}
			return deltapID;
		}

		// select delta-p ISSY code from attributes table
		String issyCode = null;
		String sql = "select id, issy_code from " + analysisTables[Excalibur.XLS] + " where section = '";
		sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + "' and mission = '";
		sql += sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + "' and ";
		sql += "(ref_intensity like '%mbar%' or UPPER(event_name) = 'PRESSLC' or UPPER(segment) = 'ALL') ";
		sql += "order by issy_code asc";
		try (ResultSet attributesTable = selectStresses.executeQuery(sql)) {
			if (attributesTable.next()) {
				issyCode = attributesTable.getString("issy_code");
				deltapID = attributesTable.getLong("id");
			}
		}

		// cannot find delta-p ISSY code
		if (issyCode == null) {
			String msg = "No ISSY code found in attributes table for delta-p load case - ";
			msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
			msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", ";
			msg += "user supplied delta-p load case number: " + dp + ". ";
			msg += "Delta-p load case will not be added to output STF file.";
			logger_.warning(msg);
			return deltapID;
		}

		// select stresses
		sql = "select sx, sy, sxy from " + analysisTables[Excalibur.STF_STRESSES] + " where file_id = ";
		sql += stfFileID + " and lc_num = " + dp + " order by abs_max_sigma desc";
		try (ResultSet stresses = selectStresses.executeQuery(sql)) {

			// loop over stresses
			int found = 0;
			String line;
			while (stresses.next()) {
				line = String.format("%-10s", issyCode);
				line += String.format("%-10s", numberFormat_.format(stresses.getDouble("sx")));
				line += String.format("%-10s", numberFormat_.format(stresses.getDouble("sy")));
				line += String.format("%-10s", numberFormat_.format(stresses.getDouble("sxy")));
				writer.write(line);
				writer.newLine();
				found++;
			}

			// no stress found
			if (found == 0) {
				if (logger_ != null) {
					String msg = "No stress found in stress input file for delta-p load case - ";
					msg += "section: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.SECTION] + ", ";
					msg += "mission: " + sectionMission[ExcaliburLoadLoadcaseCorrelations.MISSION] + ", ";
					msg += "user supplied delta-p load case number: " + dp + ", ";
					msg += "delta-p ISSY code in attributes table: " + issyCode + ". ";
					msg += "Stresses will be set to 0.0 for load case '" + issyCode + "' in the output STF file.";
					logger_.warning(msg);
				}
				line = String.format("%-10s", issyCode);
				line += String.format("%-10s", numberFormat_.format(0.0));
				line += String.format("%-10s", numberFormat_.format(0.0));
				line += String.format("%-10s", numberFormat_.format(0.0));
				writer.write(line);
				writer.newLine();
			}
		}

		// return delta-p issy code id in attributes table
		return deltapID;
	}
}
